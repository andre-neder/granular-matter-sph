#version 450
#define VULKAN 100
#define EPSILON 0.0000001f

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle{
  vec2 position;
  vec2 boundaryNormal;
  vec2 velocity;
  vec2 force;
  float rho;
  float p;
  float deltaB;
  float pad0; 
};

layout(set = 0, binding = 1) buffer StorageInput{
    Particle particles[];
} inStorage;

layout(set = 0, binding = 0) buffer StorageOutput{
    Particle particles[];
} outStorage;

layout(set = 0, binding = 3) buffer BoundaryStorage{
    Particle particles[];
} boundary;

layout(set = 0, binding = 2) uniform SPHSettings{
  vec2 G;                 // external (gravitational) forces
  float PI;
  float rhoRest;  // rest density
  float GAS_CONST; // const for equation of state
  float kernelRadius;		   // kernel radius
  float kernelRadiusSquared;		   // radius^2 for optimization
  float MASS;		   // assume all particles have the same mass
  float VISC;	   // viscosity constant
  float dt;	   // integration timestep

  // smoothing kernels defined in MÃ¼ller and their gradients
  // adapted to 2D per "SPH Based Shallow Water Simulation" by Solenthaler et al.
  float POLY6;
  float SPIKY_GRAD;
  float VISC_LAP;

  // simulation parameters
  float BOUNDARY_EPSILON; // boundary epsilon
  float BOUNDARY_DAMPING;
  float DOMAIN_WIDTH;
  float DOMAIN_HEIGHT;

  
  float pad0, pad1, pad2;
} sphSettings;

uint particleID = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x;

Particle readCurrentParticle(){
    return inStorage.particles[particleID];
}
void writeCurrentParticle(in Particle p){
    outStorage.particles[particleID] = p;
}
// https://pysph.readthedocs.io/en/latest/_modules/pysph/base/kernels.html#CubicSpline
#define KERNEL_DIM 1
#define KERNEL_FAC 2.f/3.f // One dimenion
float cubicSplineKernel(float rij, float h){
    float h1 = 1.f / h;
    float q = rij * h1;
    float fac = KERNEL_FAC * pow(h1, KERNEL_DIM);
    float tmp2 = 2.f - q;
    float val = q > 2.f ? 
        0 : 
        (q > 1.f ? 
            0.25f * pow(tmp2, 3): 
            1.f - 1.5f * q * q * (1.f - 0.5f * q)
        );
    return val * fac;
}
float dwdq(float rij, float h){
    float h1 = 1.f / h;
    float q = rij * h1;
    float fac = KERNEL_FAC * pow(h1, KERNEL_DIM);
    float tmp2 = 2.f - q;
    float val = 0.f;
    if(rij > EPSILON){
        val = q > 2.f ? 
            0 : 
            (q > 1.f ? 
                -0.75f * pow(tmp2, 2): 
                -3.f * q * (1.f - 0.75f * q)
            );
    }
    return val * fac;
}
vec2 gradient(in vec2 xij, float rij, float h){
    float h1 = 1.f / h;
    float tmp = 0.f;
    if(rij > EPSILON){
        float wdash = dwdq(rij, h);
        tmp = wdash * h1 / rij;
    }
    return xij * tmp;
}

void main(){
    Particle p = readCurrentParticle();
    vec2 pressureAcceleration = vec2(0.f, 0.f);
    float pRhoSq = p.rho * p.rho;

    // mat2 D = mat2(0);

    // mat2 velocityGradient = mat2(0);
    //* Sum up pressure forces and strain
    for (int i = 0; i < inStorage.particles.length();i++)
    {
        Particle pi = inStorage.particles[i];
        
        if (i == particleID)
        {
            continue;
        }

        vec2 p_pi = p.position - pi.position;
        float r = length(p_pi);
        
        if (r < sphSettings.kernelRadius)
        {
            float piRhoSq = pi.rho * pi.rho;
            vec2 gradient_ij = gradient(p_pi, r, sphSettings.kernelRadius);
            pressureAcceleration += sphSettings.MASS * (p.p / pRhoSq + pi.p / piRhoSq) * gradient_ij;

            // float V_j = sphSettings.MASS / pi.rho;
            // velocityGradient += V_j * outerProduct(gradient_ij, pi.velocity);

            // D += 1.f / pi.rho * outerProduct(gradient_ij, gradient_ij);
        }
    }
    //* Boundary
    for (int i = 0; i < boundary.particles.length();i++)
    {
        Particle pi = boundary.particles[i];
       
        vec2 p_pi = p.position - pi.position;
        float r = length(p_pi);
        
        if (r < sphSettings.kernelRadius)
        {
            float piRhoSq = pi.rho * pi.rho;
            vec2 gradient_ij = gradient(p_pi, r, sphSettings.kernelRadius);
            pressureAcceleration += (sphSettings.rhoRest / pi.deltaB) * (p.p / pRhoSq) * gradient_ij;

            // float V_j = sphSettings.MASS / pi.rho;
            // Todo: fix boundary velocity
            // velocityGradient += (1.f / p.deltaB) * outerProduct(gradient_ij, pi.velocity);

            // D += 1.f / pi.rho * outerProduct(gradient_ij, gradient_ij);
        }
    }
    //* Pressure force
    pressureAcceleration *= -sphSettings.MASS;

    //* Strain Tensor
    // mat2 strain = 0.5f * (velocityGradient + transpose(velocityGradient));
    
    vec2 gravity = sphSettings.G * sphSettings.MASS / p.rho;

    //* Friction & Cohesion
    // D = (2 * sphSettings.MASS * sphSettings.MASS * sphSettings.dt / pRhoSq) * D;
    // mat2 stress = inverse(D) * strain;
    // mat2 hydrostaticStress = mat2((stress[0][0] + stress[1][1]) / 2.f);
    // mat2 deviatoricStress = stress - hydrostaticStress ;

    // vec2 frictionCohesionForce = vec2(0);
    // for (int i = 0; i < inStorage.particles.length();i++)
    // {
    //     Particle pi = inStorage.particles[i];
        
    //     if (i == particleID)
    //     {
    //         continue;
    //     }

    //     vec2 p_pi = pi.position - p.position;
    //     float r = length(p_pi);
    //     //
    //     if (r < sphSettings.kernelRadius)
    //     {
    //         float piRhoSq = pi.rho * pi.rho;
    //         vec2 gradient_ij = gradient(p_pi, r, sphSettings.kernelRadius);
    //         // Todo: use separate stress for each particle
    //         frictionCohesionForce += sphSettings.MASS * (deviatoricStress / pRhoSq + deviatoricStress / piRhoSq) * gradient_ij;
    //     }
    // }
    //* Boundary
    // for (int i = 0; i < boundary.particles.length();i++)
    // {
    //     Particle pi = boundary.particles[i];

    //     vec2 p_pi = pi.position - p.position;
    //     float r = length(p_pi);
    //     //
    //     if (r < sphSettings.kernelRadius)
    //     {
    //         float piRhoSq = pi.rho * pi.rho;
    //         vec2 gradient_ij = gradient(p_pi, r, sphSettings.kernelRadius);
    //         frictionCohesionForce += (1.f / p.deltaB) * (deviatoricStress / pRhoSq) * gradient_ij;
    //     }
    // }
    // frictionCohesionForce *= -sphSettings.MASS;

    p.force = gravity + pressureAcceleration;// + frictionCohesionForce;

    writeCurrentParticle(p);
}
