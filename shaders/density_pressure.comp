#version 450
#define VULKAN 100

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle{
  vec2 position;
  vec2 velocity;
  vec2 force;
  float rho;
  float p;
};

layout(set = 0, binding = 0) buffer StorageInput{
    Particle particles[];
} inStorage;

layout(set = 0, binding = 1) buffer StorageOutput{
    Particle particles[];
} outStorage;

layout(set = 0, binding = 3) buffer BoundaryStorage{
    Particle particles[];
} boundary;

layout(set = 0, binding = 2) uniform SPHSettings{
  vec2 G;                 // external (gravitational) forces
  float PI;
  float rhoRest;  // rest density
  // 4
  float GAS_CONST; // const for equation of state
  float kernelRadius;		   // kernel radius
  float kernelRadiusSquared;		   // radius^2 for optimization
  float MASS;		   // assume all particles have the same mass
  // 8
  float VISC;	   // viscosity constant //! unused
  float dt;	   // integration timestep

  // smoothing kernels defined in MÃ¼ller and their gradients
  // adapted to 2D per "SPH Based Shallow Water Simulation" by Solenthaler et al.
  float POLY6; //! unused
  float SPIKY_GRAD; //! unused
  // 12
  float VISC_LAP; //! unused

  // simulation parameters
  float BOUNDARY_EPSILON; // boundary epsilon
  float BOUNDARY_DAMPING;
  float DOMAIN_WIDTH;
  // 16
  float DOMAIN_HEIGHT;

  float pad0, pad1, pad2;
  // 20
} sphSettings;

Particle readCurrentParticle(){
    uint particleID = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x;
    return inStorage.particles[particleID];
}
void writeCurrentParticle(in Particle p){
    uint particleID = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x;
    outStorage.particles[particleID] = p;
}

// https://pysph.readthedocs.io/en/latest/_modules/pysph/base/kernels.html#CubicSpline
#define KERNEL_DIM 1
#define KERNEL_FAC 2.f/3.f // One dimenion
float cubicSplineKernel(float rij, float h){
    float h1 = 1.f / h;
    float q = rij * h1;
    float fac = KERNEL_FAC * pow(h1, KERNEL_DIM);
    float tmp2 = 2.f - q;
    float val = q > 2.f ? 0 : (q > 1.f ? 0.25f * pow(tmp2, 3): 1.f - 1.5f * q * q * (1.f - 0.5f * q));
    return val * fac;
}

void main(){
    Particle p = readCurrentParticle();

    float sumWb = 0.f;

    p.rho = 0.f;
    for (int i = 0; i< inStorage.particles.length();i++)
    {
        Particle pi = inStorage.particles[i];
        vec2 p_pi = pi.position - p.position;
        float r2 = dot(p_pi, p_pi);
        float rij = sqrt(r2);

        if (r2 < sphSettings.kernelRadiusSquared)
        {
            p.rho += sphSettings.MASS * cubicSplineKernel(rij, sphSettings.kernelRadius);
            // Todo: Create sum for boundry 
            // for (int j = 0; j< boundary.particles.length();j++)
            // {
            //     Particle pb = boundary.particles[j];
            //     vec2 p_pb = pb.position - p.position;
            //     r2 = dot(p_pb, p_pb);
            //     rij = sqrt(r2);

            //     if (r2 < sphSettings.kernelRadiusSquared)
            //     {
            //         vec2 pi_pb = pb.position - pi.position;
            //         r2 = dot(pi_pb, pi_pb);
            //         rij = sqrt(r2);
            //         sumWb += cubicSplineKernel(rij, sphSettings.kernelRadius);
            //     }
            // }
        }
    }
    // Todo: Boundary
    // float deltaB = 1.f / sumWb;

    // for (int i = 0; i< boundary.particles.length();i++)
    // {
    //     Particle pb = boundary.particles[i];
    //     vec2 p_pb = pb.position - p.position;
    //     float r2 = dot(p_pb, p_pb);
    //     float rij = sqrt(r2);

    //     if (r2 < sphSettings.kernelRadiusSquared)
    //     {
    //         p.rho += (sphSettings.rhoRest / deltaB) * cubicSplineKernel(rij, sphSettings.kernelRadius);
    //     }
    // }

    p.rho = min(p.rho, sphSettings.rhoRest);    //* rho <= rhoRest 
    p.p = max(p.rho - sphSettings.rhoRest, 0);  //* p >= 0
    
    writeCurrentParticle(p);
}
